// Секретарь Своп

// Уже знакомый нам из предыдущей задачи граф Бабблсортер поручил своему секретарю, 
// мистеру Свопу, оформлять приглашения беднейшему, богатейшему и среднему по достатку 
// жителю своих владений. Однако кто же, в отсутствие мистера Свопа, будет заниматься 
// самым важным делом — сортировкой массивов чисел? Видимо, это придется сделать Вам!

// Дан массив, состоящий из n целых чисел. Вам необходимо его отсортировать по неубыванию. 
// Но делать это нужно так же, как это делает мистер Своп — то есть, каждое действие должно 
// быть взаимной перестановкой пары элементов. Вам также придется записать все, что Вы делали, 
// в файл, чтобы мистер Своп смог проверить Вашу работу.

// Формат входного файла
// В первой строке входного файла содержится число n(1<=n<=5000) — число элементов в массиве. Во второй 
// строке находятся  целых чисел, по модулю не превосходящих 10^9. Числа могут совпадать друг с другом.

// Формат выходного файла
// В первых нескольких строках выведите осуществленные Вами операции перестановки элементов. 
// Каждая строка должна иметь следующий формат:

// Swap elements at indices X and Y.

// где X и Y — различные индексы массива, элементы на которых нужно переставить (1<=X,Y<=n). 
// Мистер Своп любит порядок, поэтому сделайте так, чтобы X < Y.

// После того, как все нужные перестановки выведены, выведите следующую фразу:

// No more swaps needed.

// Во последней строке выходного файла выведите отсортированный массив, чтобы мистер Своп не 
// переделывал работу за Вас. Между любыми двумя числами должен стоять ровно один пробел.


#include <fstream>


void insertionsort(int n, int *m, std::ofstream &fout)
{
    int i, j, temp, x, y, k;
    
    for (j = 1; j < n; ++j) {
        for (i = j - 1; i >= 0 && m[i] > m[i + 1]; --i) {
            k = i;
            while (m[k - 1] >= m[k]) {
                k--;
                if (k == 0)
                    break;
            }
            
            temp = m[i + 1];
            m[i + 1] = m[k];
            m[k] = temp;
            fout << "Swap elements at indices " << k + 1 << " and " << i + 2 << ".\n";
            i = k;
        }
            
    }
}


int main()
{
    std::ifstream fin("input.txt");
    std::ofstream fout("output.txt");
    
    int n;
    fin >> n;
    
    int *m = new int [n];
    
    for (int i = 0; i < n; ++i)
        fin >> m[i];
    
    insertionsort(n, m, fout);
    
    fout << "No more swaps needed.\n";
    
    for (int i = 0; i < n; ++i)
        fout << m[i] << ' ';
    fout << '\n';
    
    delete [] m;
    
    return 0;
}
